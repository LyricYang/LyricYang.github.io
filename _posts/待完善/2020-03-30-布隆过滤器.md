[TOC]



## 布隆过滤器
>**布隆过滤器（Bloom Filter）**是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

**算法：**

1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

![](D:\Users\lin.yang\Desktop\备忘录\Knowledge\Algorithm\海量数据\147c7044-92f8-4ab8-a190-77aaeb78cb2b.jpg)


### 第一题 认识布隆过滤器
>不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。现在想要实现一种网页过滤系统，可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。



**解答：**

黑名单中样本的个数为100亿个，记为n；失误率不能超过0.01%，记为p；每个样本的大小为64B，这个信息不回影响布隆过滤器的大小，只和选择哈希函数有关，一般的哈希函数都可以接收64B的输入对象，所以使用布隆过滤器还有一个好处是不用顾忌单个样本的大小，它丝毫不能影响布隆过滤器的大小。
所以n=100亿，p=0.01%，布隆过滤器的大小m由以下公式确定：
$$ m=- \frac{n \times ln^p}{(ln^2)^2} $$

根据公式计算出m=19.19n，向上取整为20n，即需要2000亿个bit，也就是25GB。哈希函数的个数由以下公式决定：
$$k=ln^2 \times \frac{m}{n} = 0.7 \times \frac{m}{n}$$

计算出哈希函数的个数为k=14个。
然后用25GB的bitMap再单独实现14个哈希函数，生成布隆过滤器。
因为我们在确定布隆过滤器大小的过程中选择了向上取整，所以还要用如下公式确定布隆过滤器真实的失误率为：
$$(1-e^{- \frac{nk}{m}})^k$$

这个公式算出真实的失误率为0.006%。

### 第二题 只用2GB内存在20亿个整数中找到出现次数最多的数
>有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数。

**解答：**
哈希表的key需要占用4B，value也是4B。那么哈希表的一条记录(key,value)需要8B，当哈希记录数为2亿个时，需要至少1.6GB的内存。

解决办法是包含20亿个数的大文件用哈希函数分成16个小文件，根据哈希函数的性质，同一种数不可能被哈希到不同的小文件上，同时每个小文件中不同的数一定不会大于2亿种。然后对每一个小文件用哈希表来统计其中每种数出现的次数，选出这16个小文件各自的第一名中谁出现的次数最多即可。

### 第三题 40亿个非负整数中找到没有出现的数
>32位无符号整数的范围是0~4294967295，现在有一个真好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有没出现过的数？

**解答：**
使用bit map的方式表示数出现的情况。具体地说，是申请一个长度为4294967295的bitArr，bitArr上的每个位置值可以表示0或1状态。

首先，0~4294967295这个范围是可以平均分成64个区间的，每个区间都是67108864个数。

### 第四题 找到100亿个URL中重复的URL以及搜索词汇的topK问题
>有一个包含100亿个URL的大文件，假设每个URL占用64B,请找出其中所有重复的URL。

**解答：**
先将URL通过哈希函数分配到不同的机器的不同的小文件中，在利用小根堆选出搜索热词topK。

## 一致性哈希算法的基本原理
>一致性哈希算法在1997年由麻省理工学院的Karger等人在解决分布式Cache中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用。

**步骤：**

1. 首先求出memcached服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。
2. 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。
3. 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。

![](D:\Users\lin.yang\Desktop\备忘录\Knowledge\Algorithm\海量数据\0f8d5717-d06f-4b50-a7ff-a781a7d3c2db.jpg)